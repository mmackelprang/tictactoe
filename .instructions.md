---
applyTo: "**/*.cs,**/*.csproj"
---

# Copilot Instructions for Advanced Tic-Tac-Toe

## Project Overview

This is an advanced Tic-Tac-Toe game in C# supporting 2D and 3D gameplay with flexible board sizes and win conditions.

## Technology Stack

- Target Framework: .NET 8.0
- Language: C# 12.0
- UI: Console and GUI support

## Coding Standards

### C# Guidelines

- Use .NET 8.0 features for robust data structures and user interaction
- Follow C# naming conventions:
  - PascalCase for classes, methods, properties, and public fields
  - camelCase for local variables and private fields
  - Prefix private fields with underscore (_fieldName)
- Use nullable reference types appropriately
- Prefer `var` for local variables when the type is obvious
- Use expression-bodied members for simple properties and methods
- Prefer pattern matching and switch expressions where applicable

### Documentation Requirements

- **Include XML doc comments for all public methods, classes, properties, and interfaces**
- Use `<summary>`, `<param>`, `<returns>`, and `<exception>` tags appropriately
- Document complex logic with inline comments
- Keep comments concise and meaningful

Example:
```csharp
/// <summary>
/// Validates whether a move is legal on the board.
/// </summary>
/// <param name="position">The position to validate.</param>
/// <returns>True if the move is valid; otherwise, false.</returns>
public bool IsValidMove(Position position)
{
    // Implementation
}
```

### Code Organization

- Organize code using best practices for readability and maintainability
- Use modular design for extensibility
- Separate concerns: UI, game logic, data structures
- Keep classes focused and follow Single Responsibility Principle
- Use interfaces for abstraction (e.g., IPlayer for HumanPlayer/ComputerPlayer)

### Project Structure

Expected class organization:
- **GameController**: Manages board, players, and game loop
- **Board**: Flexible data structure supporting 2D/3D arrays with extensible win checking
- **Player** (abstract): Base class for player implementations
  - **HumanPlayer**: Human player input handling
  - **ComputerPlayer**: AI player with move selection logic
- **Position/Move**: Data structures for game state
- **WinCondition**: Logic for detecting wins across all board configurations

### Game Features

- Support resizable grids (3x3 up to 10x10)
- Adjustable win conditions (N in a row, N = 3-7)
- 3D stacked grids with multi-dimensional win checking
- Multiple game modes: Human vs. Human, Human vs. Computer, Computer vs. Computer

### Testing

- Write unit tests for game logic, win detection, and validation
- Test edge cases for different board sizes and dimensions
- Validate AI move generation
- Test all game modes

### Build and Test Commands

When project files are created:
```bash
# Build the project
dotnet build

# Run tests
dotnet test

# Run the application
dotnet run
```

## Best Practices

- Handle null values safely with nullable reference types
- Use async/await for any I/O operations
- Implement proper error handling and validation
- Prefer immutable data structures where appropriate
- Use LINQ for collection operations
- Follow defensive programming practices

## Things to Avoid

- Avoid magic numbers; use constants or enums
- Don't use outdated C# patterns (e.g., avoid explicit delegate instantiation)
- Avoid tight coupling between UI and game logic
- Don't repeat code; extract common functionality
- Avoid deep nesting; use early returns

## Performance Considerations

- Use efficient algorithms for win detection (especially for larger boards)
- Consider memory usage for 3D boards
- Cache computed values when appropriate
- Use appropriate collection types (List, HashSet, Dictionary, etc.)
